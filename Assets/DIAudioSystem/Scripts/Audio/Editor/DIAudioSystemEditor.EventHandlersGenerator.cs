using System.Linq;
using System;
using System.IO;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using ACFW;
using SimpleAudioSystem;
using SimpleAudioSystem.Settings;
using SimpleAudioSystem.Editor;
using SimpleAudioSystem.Environment;

namespace DIAudioSystem.Editor
{
    public partial class DIAudioSystemEditor
    {
        private static class EventHandlersGenerator
        {
            private readonly static string scriptTemplate = @"// This file is automatically generated by DI Audio System Editor
// Do not edit it!
// To regenerate, use Unity menu item 'Tools/Audio/DI Audio System'
// and press the 'Generate script with audio handlers' button
usi System;
using ACFW;
using SimpleAudioSystem;

namespace {0}
{{
    public class AudioEventsHandler : DIAudioSystem.IAudioEventsHandler
    {{
{1}
        public AudioEventsHandler({2})
        {{
{3}
        }}

        public void Subscribe()
        {{
{4}
        }}

        public void Unsubscribe()
        {{
{5}
        }}

        public void Dispose()
        {{
            Unsubscribe();
        }}

{6}
    }}
}}
";

            private static List<Type> eventRealms = null;
            private static List<Type> EventRealms
            {
                get
                {
                    if (eventRealms == null)
                    {
                        Type iept = typeof(IEventProvider);
                        eventRealms = AppDomain.CurrentDomain.GetAssemblies()
                            .SelectMany(a => a.GetTypes())
                            .Where(t => t != iept && iept.IsAssignableFrom(t))
                            .ToList();
                    }
                    return eventRealms;
                }
            }

            private static string GetEventRealmSuffix(string eventRealm) => eventRealm.Replace(".", "_");

            private readonly static string eventsFieldNameTemplate = "events_{0}";
            private static string GenerateEventsFieldName(string eventRealm) => string.Format(eventsFieldNameTemplate, GetEventRealmSuffix(eventRealm));

            private readonly static string argNameTemplate = "arg_{0}";
            private static string GenerateArgName(string eventRealm) => string.Format(argNameTemplate, GetEventRealmSuffix(eventRealm));

            private readonly static string eventDeclarationTemplate = "        private readonly {0} {1};\r\n";
            private static string GenerateEventDeclaration(string eventRealm) => string.Format(eventDeclarationTemplate, eventRealm, GenerateEventsFieldName(eventRealm));

            private readonly static string constructorArgTemplate = "{0} {1}";
            private static string GenerateConstructorArg(string eventRealm) => string.Format(constructorArgTemplate, eventRealm, GenerateArgName(eventRealm));

            private readonly static string containerAssignTemplate = "            {0} = {1};\r\n";
            private static string GenerateContainerAssignment(string eventRealm) => string.Format(containerAssignTemplate, GenerateEventsFieldName(eventRealm), GenerateArgName(eventRealm));

            private readonly static string subscribeTemplate = "            {0}.{1} += {2};\r\n";
            private readonly static string unsubscribeTemplate = "            {0}.{1} -= {2};\r\n";
            private readonly static string handlerTemplate = @"        private void {0}({1})
        {{
            {2}.{3}?.Invoke({4});
        }}
";

            private readonly static string sfxEventName = nameof(AudioEvents.PlaySFX);
            private readonly static string musicEventName = nameof(AudioEvents.PlayMusic);

            private class ScriptParts
            {
                public HashSet<string> eventDeclarations = new HashSet<string>();
                public List<string> constructorArgs = new List<string>();
                public List<string> subscribes = new List<string>();
                public List<string> unsubscribes = new List<string>();
                public List<string> handlers = new List<string>();
            }

            public static void Generate(string filename, string projectNamespace, AudioClipSettings audioClipSettings, SimpleAudioSystem.Editor.AudioEventSettings audioEventSettings)
            {
                if (!string.IsNullOrEmpty(filename) && audioEventSettings != null)
                {
                    Directory.CreateDirectory(Path.GetDirectoryName(filename));
                    var scriptParts = new ScriptParts();
                    scriptParts.eventDeclarations.Add(typeof(AudioEvents).FullName);
                    var subParts = GenerateSFXSubscribers(audioClipSettings, audioEventSettings.sfxDescriptors);
                    if (subParts != null)
                    {
                        foreach (var eventDeclaration in subParts.eventDeclarations)
                        {
                            scriptParts.eventDeclarations.Add(eventDeclaration);
                        }
                        scriptParts.subscribes.AddRange(subParts.subscribes);
                        scriptParts.unsubscribes.AddRange(subParts.unsubscribes);
                        scriptParts.handlers.AddRange(subParts.handlers);
                    }
                    subParts = GenerateMusicSubscribers(audioClipSettings, audioEventSettings.musicDescriptors);
                    if (subParts != null)
                    {
                        foreach (var eventDeclaration in subParts.eventDeclarations)
                        {
                            scriptParts.eventDeclarations.Add(eventDeclaration);
                        }
                        scriptParts.subscribes.AddRange(subParts.subscribes);
                        scriptParts.unsubscribes.AddRange(subParts.unsubscribes);
                        scriptParts.handlers.AddRange(subParts.handlers);
                    }
                    using (StreamWriter writer = new StreamWriter(filename))
                    {
                        string scriptText = string.Format(
                            scriptTemplate,     // template
                            projectNamespace,   // namespace
                            string.Join(string.Empty, scriptParts.eventDeclarations.Select(d => GenerateEventDeclaration(d))),      // event declarations
                            string.Join(", ", scriptParts.eventDeclarations.Select(d => GenerateConstructorArg(d))),                // constructor arguments
                            string.Join(string.Empty, scriptParts.eventDeclarations.Select(d => GenerateContainerAssignment(d))),   // event assignments
                            string.Join(string.Empty, scriptParts.subscribes),                                                      // Subscribe
                            string.Join(string.Empty, scriptParts.unsubscribes),                                                    // Unsubscribe
                            string.Join(string.Empty, scriptParts.handlers));                                                       // handlers
                        writer.Write(scriptText);
                    }
                    AssetDatabase.Refresh();
                }
                else
                {
                    Debug.LogError($"AudioEventSettings is empty");
                }
            }

            private static string GenerateHandlerArgs(EventDescriptor descriptor)
            {
                string result = string.Empty;
                var eventRealm = EventRealms.FirstOrDefault(t => t.FullName == descriptor.eventRealm.Replace("/", "."));
                if (eventRealm != null)
                {
                    var eventField = eventRealm.GetFields().FirstOrDefault(e => e.Name == descriptor.eventName);
                    if (eventField != null)
                    {
                        var eventFieldType = eventField.FieldType;
                        var eventFieldGenericArguments = eventFieldType.IsGenericType ? eventFieldType.GetGenericArguments() : new Type[0];
                        switch (eventFieldGenericArguments.Length)
                        {
                            case 0:
                                break;
                            default:
                                string delimiter = string.Empty;
                                for (int i = 0; i < eventFieldGenericArguments.Length; ++i)
                                {
                                    var arg = eventFieldGenericArguments[i];
                                    result += delimiter + arg.Name + " arg" + (i + 1).ToString();
                                    delimiter = ", ";
                                }
                                break;
                        }
                    }
                }
                return result;
            }

            private static string FromDescriptorToType(string s) => s.Replace("/", ".");
            private readonly static string handlerNameTemplate = "{0}_{1}_{2}";
            private static string GenerateHandlerName(string eventRealm, string eventName, int eventType) =>
                string.Format(handlerNameTemplate, GetEventRealmSuffix(FromDescriptorToType(eventRealm)), eventName, eventType);

            private static ScriptParts GenerateSFXSubscribers(AudioClipSettings audioClipSettings, SFXEventDescriptor[] descriptors)
            {
                var tree = MusicSFXTypesGenerator.CreateSFXTree(audioClipSettings);
                ScriptParts scriptParts = new ScriptParts();
                foreach (var descriptor in descriptors)
                {
                    Debug.Log($"Parsing {descriptor.GetType().Name}: eventRealm={descriptor.eventRealm}, eventName={descriptor.eventName}, value={descriptor.sfxType}");
                    scriptParts.eventDeclarations.Add(FromDescriptorToType(descriptor.eventRealm));
                    string handlerName = GenerateHandlerName(descriptor.eventRealm, descriptor.eventName, descriptor.sfxType);
                    scriptParts.subscribes.Add(string.Format(subscribeTemplate, GenerateEventsFieldName(FromDescriptorToType(descriptor.eventRealm)), descriptor.eventName, handlerName));
                    scriptParts.unsubscribes.Add(string.Format(unsubscribeTemplate, GenerateEventsFieldName(FromDescriptorToType(descriptor.eventRealm)), descriptor.eventName, handlerName));
                    string valuePath = nameof(SFXTrackType) + "." + FromDescriptorToType(tree.GetLeafPath(descriptor.sfxType));
                    scriptParts.handlers.Add(string.Format(handlerTemplate, handlerName, GenerateHandlerArgs(descriptor), GenerateEventsFieldName(typeof(AudioEvents).FullName), sfxEventName, valuePath));
                }
                return scriptParts;
            }

            private static ScriptParts GenerateMusicSubscribers(AudioClipSettings audioClipSettings, MusicEventDescriptor[] descriptors)
            {
                var tree = MusicSFXTypesGenerator.CreateMusicTree(audioClipSettings);
                ScriptParts scriptParts = new ScriptParts();
                foreach (var descriptor in descriptors)
                {
                    Debug.Log($"Parsing {descriptor.GetType().Name}: eventRealm={descriptor.eventRealm}, eventName={descriptor.eventName}, value={descriptor.musicType}");
                    scriptParts.eventDeclarations.Add(FromDescriptorToType(descriptor.eventRealm));
                    string handlerName = GenerateHandlerName(descriptor.eventRealm, descriptor.eventName, descriptor.musicType);
                    scriptParts.subscribes.Add(string.Format(subscribeTemplate, GenerateEventsFieldName(FromDescriptorToType(descriptor.eventRealm)), descriptor.eventName, handlerName));
                    scriptParts.unsubscribes.Add(string.Format(unsubscribeTemplate, GenerateEventsFieldName(FromDescriptorToType(descriptor.eventRealm)), descriptor.eventName, handlerName));
                    string valuePath = nameof(MusicTrackType) + "." + FromDescriptorToType(tree.GetLeafPath(descriptor.musicType));
                    scriptParts.handlers.Add(string.Format(handlerTemplate, handlerName, GenerateHandlerArgs(descriptor), GenerateEventsFieldName(typeof(AudioEvents).FullName), musicEventName, valuePath));
                }
                return scriptParts;
            }
        }
    }
}
